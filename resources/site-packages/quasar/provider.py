# coding: utf-8
import base64
import json
import sys
import traceback
import urllib2
from cookielib import CookieJar, LWPCookieJar
from os import path
import re
from urllib import urlencode

import xbmcaddon
import xbmcgui

from quasar.addon import ADDON, ADDON_ID
from quasar.config import QUASARD_HOST
from quasar.logger import log
from quasar.util import notify, getLocalizedString

RESOLUTION_UNKNOWN = 0
RESOLUTION_480P = 1
RESOLUTION_720P = 2
RESOLUTION_1080P = 3
RESOLUTION_1440P = 4
RESOLUTION_4K2K = 5

RIP_UNKNOWN = 0
RIP_CAM = 1
RIP_TS = 2
RIP_TC = 3
RIP_SCR = 4
RIP_DVDSCR = 5
RIP_DVD = 6
RIP_HDTV = 7
RIP_WEB = 8
RIP_BLURAY = 9

RATING_UNKNOWN = 0
RATING_PROPER = 1
RATING_NUKED = 2

CODEC_UNKNOWN = 0
CODEC_XVID = 1
CODEC_H264 = 2
CODEC_MP3 = 3
CODEC_AAC = 4
CODEC_AC3 = 5
CODEC_DTS = 6
CODEC_DTSHD = 7
CODEC_DTSHDMA = 8

USER_AGENT = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/30.0.1599.66 Safari/537.36"

COOKIE_JAR = CookieJar()
urllib2.install_opener(urllib2.build_opener(urllib2.HTTPCookieProcessor(COOKIE_JAR)))

season_names = {'en': 'season',
                'es': 'temporada',
                'fr': 'saison',
                'nl': 'seizoen',
                'ru': 'сезон',
                'it': 'stagione',
                'de': 'saison',
                'pt': 'temporada',
                }


class closing(object):
    def __init__(self, thing):
        self.thing = thing

    def __enter__(self):
        return self.thing

    def __exit__(self, *exc_info):
        self.thing.close()


def parse_json(data):
    try:
        import simplejson as json
    except ImportError:
        import json
    return json.loads(data)


def parse_xml(data):
    import xml.etree.ElementTree as ET
    return ET.fromstring(data)


def request(url, params={}, headers={}, data=None, method=None):
    if params:
        url = "".join([url, "?", urlencode(params)])

    req = urllib2.Request(url)
    if method:
        req.get_method = lambda: method
    req.add_header("User-Agent", USER_AGENT)
    req.add_header("Accept-Encoding", "gzip")
    for k, v in headers.items():
        req.add_header(k, v)
    if data:
        req.add_data(data)
    try:
        with closing(urllib2.urlopen(req)) as response:
            data = response.read()
            if response.headers.get("Content-Encoding", "") == "gzip":
                import zlib
                data = zlib.decompressobj(16 + zlib.MAX_WBITS).decompress(data)
            response.data = data
            response.json = lambda: parse_json(data)
            response.xml = lambda: parse_xml(data)
            return response
    except Exception as e:
        notify("%s: %s" % (getLocalizedString(30224), repr(e).encode('utf-8')))
        map(log.error, traceback.format_exc().split("\n"))
        return None, None


HEAD = lambda *args, **kwargs: request(*args, method="HEAD", **kwargs)
GET = lambda *args, **kwargs: request(*args, method="GET", **kwargs)
POST = lambda *args, **kwargs: request(*args, method="POST", **kwargs)
PUT = lambda *args, **kwargs: request(*args, method="PUT", **kwargs)
DELETE = lambda *args, **kwargs: request(*args, method="DELETE", **kwargs)


def append_headers(uri, headers):
    return uri + "|" + "|".join(["%s=%s" % h for h in headers.items()])


def with_cookies(uri):
    return uri + "|Cookies=" + "; ".join(["%s=%s" % (c.name, c.value) for c in COOKIE_JAR])


def extract_magnets(data):
    import re
    for magnet in re.findall(r'magnet:\?[^\'"\s<>\[\]]+', data):
        yield {"uri": magnet}


def parse_rss(root):
    NSMAP = {
        "torrent": "http://xmlns.ezrss.it/0.1/",
        "showrss": "http://showrss.info/",
    }

    def _maybe_int(val):
        try:
            return int(val)
        except:
            return 0

    def _text(node, path):
        n = node.find(path)
        if n is not None:
            return n.text

    def _attr(node, path, attrib):
        n = node.find(path)
        if n is not None:
            return n.attrib.get(attrib)

    for item in root.getiterator("item"):
        yield {
            "name": _text(item, "title") or _text(item, ".//{%(torrent)s}fileName" % NSMAP) or _text(item,
                                                                                                     ".//{%(showrss)s}rawtitle" % NSMAP),
            "info_hash": _text(item, ".//info_hash") or _text(item, ".//{%(showrss)s}info_hash" % NSMAP),
            "uri": _text(item, ".//{%(torrent)s}magnetURI" % NSMAP) or _attr(item, ".//enclosure", "url") or _text(item,
                                                                                                                   "./link"),
            "seeds": _maybe_int(
                _text(item, ".//{%(torrent)s}seeds" % NSMAP) or _text(item, "numSeeders") or _text(item, "seeders")),
            "peers": _maybe_int(
                _text(item, ".//{%(torrent)s}peers" % NSMAP) or _text(item, "numLeechers") or _text(item, "leechers")),
            "size": _maybe_int(
                _text(item, ".//{%(torrent)s}contentLength" % NSMAP) or _attr(item, ".//enclosure", "length")),
        }


# Borrowed from xbmcswift2
def get_setting(key, converter=str, choices=None):
    value = ADDON.getSetting(id=key)
    if converter is str:
        return value
    elif converter is unicode:
        return value.decode('utf-8')
    elif converter is bool:
        return value == 'true'
    elif converter is int:
        return int(value)
    elif isinstance(choices, (list, tuple)):
        return choices[int(value)]
    else:
        raise TypeError('Acceptable converters are str, unicode, bool and '
                        'int. Acceptable choices are instances of list '
                        ' or tuple.')


def set_setting(key, val):
    return ADDON.setSetting(id=key, value=val)


def register(search, search_movie, search_episode, search_season=None):
    try:
        payload = json.loads(base64.b64decode(sys.argv[1]))
    except:
        notify(getLocalizedString(30102), time=1000)
        return

    results = ()
    method = {
                 "search": search,
                 "search_movie": search_movie,
                 "search_season": search_season,
                 "search_episode": search_episode,
             }.get(payload["method"]) or (lambda *a, **kw: [])
    try:
        results = ()
        try:
            objects = method(payload["search_object"])
            if objects is not None:
                results = tuple(objects)
        except Exception as e:
            notify("%s: %s" % (getLocalizedString(30224), repr(e).encode('utf-8')))
            try:
                urllib2.urlopen("%s/provider/%s/failure" % (QUASARD_HOST, ADDON_ID))
            except:
                pass
            map(log.error, traceback.format_exc().split("\n"))
    finally:
        try:
            req = urllib2.Request(payload["callback_url"], data=json.dumps(results))
            with closing(urllib2.urlopen(req)) as response:
                log.info("%s" % repr(response))
        except Exception as e:
            notify("%s: %s" % (getLocalizedString(30224), repr(e).encode('utf-8')))
            try:
                urllib2.urlopen("%s/provider/%s/failure" % (QUASARD_HOST, ADDON_ID))
            except:
                pass
            map(log.error, traceback.format_exc().split("\n"))


# provider web browser with cookies management
class Browser:
    def __init__(self):
        pass

    _cookies = None
    cookies = LWPCookieJar()
    content = None
    status = None

    @classmethod
    def create_cookies(cls, payload):

        cls._cookies = urlencode(payload)

    # to open any web page
    @classmethod
    def open(cls, url='', language='en', payload=None):
        if payload is None:
            payload = {}

        result = True
        if len(payload) > 0:
            cls.create_cookies(payload)
        if cls._cookies is not None:
            req = urllib2.Request(url, cls._cookies)
            cls._cookies = None
        else:
            req = urllib2.Request(url)
        req.add_header('User-Agent', USER_AGENT)
        req.add_header('Content-Language', language)
        req.add_header("Accept-Encoding", "gzip")
        opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cls.cookies))  # open cookie jar
        try:
            response = opener.open(req)  # send cookies and open url
            # borrow from provider.py Steeve
            if response.headers.get("Content-Encoding", "") == "gzip":
                import zlib
                cls.content = zlib.decompressobj(16 + zlib.MAX_WBITS).decompress(response.read())
            else:
                cls.content = response.read()
            response.close()
            cls.status = 200
        except urllib2.HTTPError as e:
            cls.status = e.code
            result = False
        except urllib2.URLError as e:
            cls.status = e.reason
            result = False
        return result

    # alternative when it is problem with https
    @classmethod
    def open2(cls, url=''):
        import httplib

        word = url.split("://")
        pos = word[1].find("/")
        conn = httplib.HTTPConnection(re.search[:pos])
        conn.request("GET", re.search[pos:])
        r1 = conn.getresponse()
        cls.status = str(r1.status) + " " + r1.reason
        cls.content = r1.read()
        if r1.status == 200:
            return True
        else:
            return False

    # used for sites with login
    @classmethod
    def login(cls, url, payload, word):
        result = False
        cls.create_cookies(payload)
        if cls.open(url):
            result = True
            data = cls.content
            if word in data:
                cls.status = 'Wrong Username or Password'
                result = False
        return result


# find the name in different language
def translator(imdb_id, language, extra=True):
    import json
    keywords = {'en': '', 'de': '', 'es': 'espa', 'fr': 'french', 'it': 'italian', 'pt': 'portug'}
    url_themoviedb = "http://api.themoviedb.org/3/find/%s?api_key=8d0e4dca86c779f4157fc2c469c372ca&language=%s" \
                     "&external_source=imdb_id" % (imdb_id, language)
    if Browser.open(url_themoviedb):
        results = json.loads(Browser.content)
        if len(results['movie_results']) > 0:
            title = results['movie_results'][0]['title'].encode('utf-8')
            original_title = results['movie_results'][0]['original_title'].encode('utf-8')
        elif len(results['tv_results']) > 0:
            title = results['tv_results'][0]['name'].encode('utf-8')
            original_title = results['tv_results'][0]['original_name'].encode('utf-8')
        else:
            title = ""
            original_title = ""
        if title == original_title and extra:
            title += ' ' + keywords[language]
    else:
        title = 'Pas de communication avec le themoviedb.org'
    return title.rstrip()


#  Get the title from imdb id code
def imdb_title(imdb_id):
    result = ''
    if Browser.open('http://www.omdbapi.com/?i=%s&r=json' % imdb_id):
        data = Browser.content.replace('"', '').replace('{', '').replace('}', '').split(',')
        result = data[0].split(":")[1] + ' ' + data[1].split(":")[1]
    return result


# get the first magnet or torrent from one webpage
def get_links(page):
    browser = Browser()
    result = ""
    if browser.open(page.encode("UTF-8")):
        content = re.findall('magnet:\?[^\'"\s<>\[\]]+', browser.content)
        if content is not None:
            result = content[0]
        else:
            content = re.findall('http(.*?).torrent', browser.content)
            if content is not None:
                result = 'http' + content[0] + '.torrent'
    return result


def size_int(size_txt):
    size_txt = size_txt.upper()
    size1 = size_txt.replace('B', '').replace('I', '').replace('K', '').replace('M', '').replace('G', '')
    size = get_float(size1)
    if 'K' in size_txt:
        size *= 1000
    if 'M' in size_txt:
        size *= 1000000
    if 'G' in size_txt:
        size *= 1e9
    return get_int(size)


def get_int(text):
    # noinspection PyBroadException
    try:
        value = int(re.search('([0-9]*\.[0-9]+|[0-9]+)', text).group(0))
    except:
        value = 0
    return value


def get_float(text):
    # noinspection PyBroadException
    try:
        value = float(re.search('([0-9]*\.[0-9]+|[0-9]+)', text).group(0))
    except:
        value = 0
    return value


# read provider settings
class Settings:
    def __init__(self):
        pass

    dialog = xbmcgui.Dialog()
    pDialog = xbmcgui.DialogProgress()
    settings = xbmcaddon.Addon()

    # General information
    idAddon = settings.getAddonInfo('ID')  # gets name
    icon = settings.getAddonInfo('icon')
    fanart = settings.getAddonInfo('fanart')
    path_folder = settings.getAddonInfo('path')
    name = settings.getAddonInfo('name')  # gets name
    cleanName = re.sub('.COLOR (.*?)]', '', name.replace('[/COLOR]', ''))
    value = {}  # it contains all the settings from xml file
    with open(path.join(path_folder, "resources", "settings.xml"), 'r') as fp:
        data = fp.read()
    for key in re.findall('id="(\w+)"', data):
        value[key] = get_setting(key)  # reading the values from settings.xml
    if 'url_address' in value and value['url_address'].endswith('/'):
        value['url_address'] = value['url_address'][:-1]


# filtering
class Filtering:
    def __init__(self):
        pass

    settings = xbmcaddon.Addon()
    id_addon = settings.getAddonInfo('id')  # gets name
    time_noti = int(settings.getSetting('time_noti'))  # time notification
    icon = settings.getAddonInfo('icon')
    name_provider = re.sub('.COLOR (.*?)]', '', settings.getAddonInfo('name').replace('[/COLOR]', ''))
    reason = ''
    title = ''
    info = {}
    quality_allow = ['*']
    quality_deny = []
    max_size = 10.00  # 10 it is not limit
    min_size = 0.00
    # size
    if settings.getSetting('movie_min_size') == '':
        movie_min_size = 0.0
    else:
        movie_min_size = float(settings.getSetting('movie_min_size'))
    if settings.getSetting('movie_max_size') == '':
        movie_max_size = 10.0
    else:
        movie_max_size = float(settings.getSetting('movie_max_size'))
    if settings.getSetting('TV_min_size') == '':
        TV_min_size = 0.0
    else:
        TV_min_size = float(settings.getSetting('TV_min_size'))
    if settings.getSetting('TV_max_size') == '':
        TV_max_size = 10.0
    else:
        TV_max_size = float(settings.getSetting('TV_max_size'))

    # movie
    movie_qua1 = settings.getSetting('movie_qua1')  # 480p
    movie_qua2 = settings.getSetting('movie_qua2')  # HDTV
    movie_qua3 = settings.getSetting('movie_qua3')  # 720p
    movie_qua4 = settings.getSetting('movie_qua4')  # 1080p
    movie_qua5 = settings.getSetting('movie_qua5')  # 3D
    movie_qua6 = settings.getSetting('movie_qua6')  # CAM
    movie_qua7 = settings.getSetting('movie_qua7')  # TeleSync
    movie_qua8 = settings.getSetting('movie_qua8')  # Trailer
    # Accept File
    movie_key_allowed = settings.getSetting('movie_key_allowed').replace(', ', ',').replace(' ,', ',')
    movie_allow = re.split(',', movie_key_allowed)
    if movie_qua1 == 'Accept File': movie_allow.append('480p')
    if movie_qua2 == 'Accept File': movie_allow.append('HDTV')
    if movie_qua3 == 'Accept File': movie_allow.append('720p')
    if movie_qua4 == 'Accept File': movie_allow.append('1080p')
    if movie_qua5 == 'Accept File': movie_allow.append('3D')
    if movie_qua6 == 'Accept File': movie_allow.append('CAM')
    if movie_qua7 == 'Accept File': movie_allow.extend(['TeleSync', ' TS '])
    if movie_qua8 == 'Accept File': movie_allow.append('Trailer')
    # Block File
    movie_key_denied = settings.getSetting('movie_key_denied').replace(', ', ',').replace(' ,', ',')
    movie_deny = re.split(',', movie_key_denied)
    if movie_qua1 == 'Block File': movie_deny.append('480p')
    if movie_qua2 == 'Block File': movie_deny.append('HDTV')
    if movie_qua3 == 'Block File': movie_deny.append('720p')
    if movie_qua4 == 'Block File': movie_deny.append('1080p')
    if movie_qua5 == 'Block File': movie_deny.append('3D')
    if movie_qua6 == 'Block File': movie_deny.append('CAM')
    if movie_qua7 == 'Block File': movie_deny.extend(['TeleSync', '?TS?'])
    if movie_qua8 == 'Block File': movie_deny.append('Trailer')
    if '' in movie_allow: movie_allow.remove('')
    if '' in movie_deny: movie_deny.remove('')
    if len(movie_allow) == 0: movie_allow = ['*']
    movie_allow = movie_allow
    movie_deny = movie_deny
    # TV
    TV_qua1 = settings.getSetting('TV_qua1')  # 480p
    TV_qua2 = settings.getSetting('TV_qua2')  # HDTV
    TV_qua3 = settings.getSetting('TV_qua3')  # 720p
    TV_qua4 = settings.getSetting('TV_qua4')  # 1080p
    # Accept File
    TV_key_allowed = settings.getSetting('TV_key_allowed').replace(', ', ',').replace(' ,', ',')
    TV_allow = re.split(',', TV_key_allowed)
    if TV_qua1 == 'Accept File': TV_allow.append('480p')
    if TV_qua2 == 'Accept File': TV_allow.append('HDTV')
    if TV_qua3 == 'Accept File': TV_allow.append('720p')
    if TV_qua4 == 'Accept File': TV_allow.append('1080p')
    # Block File
    TV_key_denied = settings.getSetting('TV_key_denied').replace(', ', ',').replace(' ,', ',')
    TV_deny = re.split(',', TV_key_denied)
    if TV_qua1 == 'Block File': TV_deny.append('480p')
    if TV_qua2 == 'Block File': TV_deny.append('HDTV')
    if TV_qua3 == 'Block File': TV_deny.append('720p')
    if TV_qua4 == 'Block File': TV_deny.append('1080p')
    if '' in TV_allow: TV_allow.remove('')
    if '' in TV_deny: TV_deny.remove('')
    if len(TV_allow) == 0: TV_allow = ['*']
    TV_allow = TV_allow
    TV_deny = TV_deny

    @classmethod
    def type_filtering(cls, info, separator='%20'):
        from xbmcgui import Dialog
        from urllib import quote

        if 'movie' == info["type"]:
            cls.use_movie()
        elif 'show' == info["type"]:
            cls.use_tv()
            info["query"] = exception(info["query"])  # CSI series problem
        elif 'anime' == info["type"]:
            cls.use_tv()
        cls.title = info["query"] + ' ' + info["extra"]  # to do filtering by name
        cls.info = info
        if cls.time_noti > 0:
            dialog = Dialog()
            dialog.notification(cls.name_provider, info["query"].title(), cls.icon, cls.time_noti)
            del Dialog
        return quote(info["query"].rstrip()).replace('%20', separator)

    @classmethod
    def use_movie(cls):
        cls.quality_allow = cls.movie_allow
        cls.quality_deny = cls.movie_deny
        cls.min_size = cls.movie_min_size
        cls.max_size = cls.movie_max_size

    @classmethod
    def use_tv(cls):
        cls.quality_allow = cls.TV_allow
        cls.quality_deny = cls.TV_deny
        cls.min_size = cls.TV_min_size
        cls.max_size = cls.TV_max_size

    @classmethod
    def information(cls):
        log.info('[%s] Accepted Keywords: %s' % (cls.id_addon, str(cls.quality_allow)))
        log.info('[%s] Blocked Keywords: %s' % (cls.id_addon, str(cls.quality_deny)))
        log.info('[%s] min Size: %s' % (cls.id_addon, str(cls.min_size) + ' GB'))
        log.info(
            '[%s] max Size: %s' % (cls.id_addon, (str(cls.max_size) + ' GB') if cls.max_size != 10 else 'MAX'))

    # validate keywords
    @staticmethod
    def included(value, keys, strict=False):
        value = ' ' + value + ' '
        if '*' in keys:
            res = True
        else:
            res1 = []
            for key in keys:
                res2 = []
                for item in re.split('\s', key):
                    item = item.replace('?', ' ')
                    if strict:
                        item = ' ' + item + ' '  # it makes that strict the comparation
                    if item.upper() in value.upper():
                        res2.append(True)
                    else:
                        res2.append(False)
                res1.append(all(res2))
            res = any(res1)
        return res

    # validate size
    @classmethod
    def size_clearance(cls, size):
        max_size1 = 100 if cls.max_size == 10 else cls.max_size
        res = False
        value = get_float(size)
        value *= 0.001 if 'M' in size else 1
        if cls.min_size <= value <= max_size1:
            res = True
        return res

    @staticmethod
    def normalize(name):
        from unicodedata import normalize
        import types

        if types.StringType == type(name):
            unicode_name = unicode(name, 'utf-8', 'ignore')
        else:
            unicode_name = name
        normalize_name = normalize('NFKD', unicode_name)
        return normalize_name.encode('ascii', 'ignore')

    @staticmethod
    def un_code_name(name):  # convert all the &# codes to char, remove extra-space and normalize
        from HTMLParser import HTMLParser

        name = name.replace('<![CDATA[', '').replace(']]', '')
        name = HTMLParser().unescape(name.lower())
        return name

    @staticmethod
    def unquote_name(name):  # convert all %symbols to char
        from urllib import unquote

        return unquote(name).decode("utf-8")

    @classmethod
    def safe_name(cls, value):  # make the name directory and filename safe
        value = cls.normalize(value)  # First normalization
        value = cls.unquote_name(value)
        value = cls.un_code_name(value)
        value = cls.normalize(
            value)  # Last normalization, because some unicode char could appear from the previous steps
        value = value.lower().title()
        keys = {'"': ' ', '*': ' ', '/': ' ', ':': ' ', '<': ' ', '>': ' ', '?': ' ', '|': ' ',
                "'": '', 'Of': 'of', 'De': 'de', '.': ' ', ')': ' ', '(': ' ', '[': ' ', ']': ' ', '-': ' '}
        for key in keys.keys():
            value = value.replace(key, keys[key])
        value = ' '.join(value.split())
        return value.replace('S H I E L D', 'SHIELD')

    # verify
    @classmethod
    def verify(cls, name, size):
        name = cls.safe_name(name)
        cls.title = cls.safe_name(cls.title)
        cls.reason = name.replace(' - ' + cls.name_provider, '') + ' ***Blocked File by'
        if cls.included(name, [cls.title], True):
            result = True
            if name is not None:
                if not cls.included(name, cls.quality_allow) or cls.included(name, cls.quality_deny):
                    cls.reason += ", Keyword"
                    result = False
            if size is not None:
                if not cls.size_clearance(size):
                    result = False
                    cls.reason += ", Size"
        else:
            result = False
            cls.reason += ", Name"
        cls.reason = cls.reason.replace('by,', 'by') + '***'
        return result


class Magnet:
    def __init__(self, magnet):
        self.magnet = magnet + '&'
        # hash
        info_hash = re.search('urn:btih:(.*?)&', self.magnet)
        result = ''
        if info_hash is not None:
            result = info_hash.group(1)
        self.hash = result
        # name
        name = re.search('dn=(.*?)&', self.magnet)
        result = ''
        if name is not None:
            result = name.group(1).replace('+', ' ')
        self.name = result.title()
        # trackers
        self.trackers = re.findall('tr=(.*?)&', self.magnet)


def exception(title):
    title = title.lower()
    title = title.replace('csi crime scene investigation', 'CSI')
    title = title.replace('law and order special victims unit', 'law and order svu')
    title = title.replace('law order special victims unit', 'law and order svu')
    return title
